read_and_label <- function(file) {
# Read the CSV file
df <- read_csv(file)
# Extract file name without extension and add as 'id' column
df <- df %>% mutate(id = tools::file_path_sans_ext(basename(file)))
return(df)
}
# Load and label each CSV, then combine into one dataframe
matching_df <- bind_rows(lapply(file_list, read_and_label))
matching_df <- drop_na(matching_df, eda)
View(matching_df)
# Store cross-correlation values for each participant, lag, and condition
participant_ids <- unique(combined_df$id)
conditions <- unique(matching_df$condition)
all_results <- list()
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
View(ccf_df)
View(matching_data)
# Store cross-correlation values for each participant, lag, and condition
conditions <- unique(matching_df$condition)
all_results <- list()
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
# Get the participant IDs present in this condition
participant_ids <- unique(condition_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
library(stats)
library(boot)
# Store cross-correlation values for each participant, lag, and condition
conditions <- unique(matching_df$condition)
all_results <- list()
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
# Get the participant IDs present in this condition
participant_ids <- unique(condition_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
library(boot)
# Define the function for bootstrapping
mean_ccf <- function(data, indices) {
mean(data[indices], na.rm = TRUE)
}
# Store cross-correlation values for each participant, lag, and condition
conditions <- unique(matching_df$condition)
all_results <- list()
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
# Get the participant IDs present in this condition
participant_ids <- unique(condition_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
library(boot)
# Define the function for bootstrapping
mean_ccf <- function(data, indices) {
mean(data[indices], na.rm = TRUE)
}
# Store cross-correlation values for each participant, lag, and condition
conditions <- unique(matching_df$condition)
all_results <- list()
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
# Get the participant IDs present in this condition
participant_ids <- unique(condition_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
View(subj_data)
library(boot)
# Store cross-correlation values for each participant, lag, and condition
conditions <- unique(matching_df$condition)
all_results <- list()
error_ids <- list()  # List to store IDs that give errors
# Collect cross-correlation data for each condition
for (cond in conditions) {
# Filter data for the current condition
condition_matching_df <- matching_df %>% filter(condition == cond)
# Get the participant IDs present in this condition
participant_ids <- unique(condition_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
# Use tryCatch to handle errors
tryCatch({
subj_data <- combined_df %>% filter(id == i)
matching_data <- condition_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}, error = function(e) {
# If an error occurs, store the participant ID
error_ids <<- c(error_ids, i)
})
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results[[cond]] <- bootstrap_results
}
# Print results for each condition
for (cond in names(all_results)) {
cat("\nResults for condition:", cond, "\n")
print(all_results[[cond]])
}
# Print IDs that caused errors
cat("\nParticipants that caused errors:\n")
print(error_ids)
View(combined_df)
# Combine all results into one dataframe
combined_results <- bind_rows(lapply(names(all_results), function(cond) {
all_results[[cond]] %>%
mutate(condition = cond)
}))
# Plot using ggplot2
ggplot(combined_results, aes(x = lag, y = mean_ccf, color = condition, fill = condition)) +
geom_line() +  # Line plot for mean cross-correlation
geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +  # Shaded area for CI
labs(
title = "Aggregated Cross-Correlation by Lag for Each Condition",
x = "Lag",
y = "Mean Cross-Correlation",
color = "Condition",
fill = "Condition"
) +
theme_cowplot()
View(condition_matching_df)
View(combined_df)
print(count(unique(combined_df$id)))))
print(count(unique(combined_df$id))))
print(count(unique(combined_df$id)))
print(n(unique(combined_df$id)))
print(unique(combined_df$id))
View(matching_df)
library(boot)
# Store cross-correlation values for each participant, lag, and round_num
# Round number as a factor
matching_df$round_num <- as.factor(matching_df$round_num)
round_num <- unique(matching_df$round_num)
all_results_num <- list()
error_ids_num <- list()  # List to store IDs that give errors
# Collect cross-correlation data for each condition
for (num in round_num) {
# Filter data for the current condition
num_matching_df <- matching_df %>% filter(round_num == num)
# Get the participant IDs present in this condition
participant_ids <- unique(num_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this condition
for (i in participant_ids) {
# Use tryCatch to handle errors
tryCatch({
subj_data <- combined_df %>% filter(id == i)
matching_data <- num_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}, error = function(e) {
# If an error occurs, store the participant ID
error_ids_num <<- c(error_ids, i)
})
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = mean_ccf, R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results_num[[num]] <- bootstrap_results
}
library(boot)
# Store cross-correlation values for each participant, lag, and round_num
matching_df$round_num <- as.factor(matching_df$round_num)
round_num <- unique(matching_df$round_num)
all_results_num <- list()
error_ids_num <- list()  # List to store IDs that give errors
# Collect cross-correlation data for each round number
for (num in round_num) {
# Filter data for the current round number
num_matching_df <- matching_df %>% filter(round_num == num)
# Get the participant IDs present in this round
participant_ids <- unique(num_matching_df$id)
ccf_values <- data.frame()
# Collect cross-correlation data for each participant in this round
for (i in participant_ids) {
# Use tryCatch to handle errors
tryCatch({
subj_data <- combined_df %>% filter(id == i)
matching_data <- num_matching_df %>% filter(id == i)
scr_series <- ts(subj_data$SCR_Peaks, frequency = 1)
ccf_result <- ccf(scr_series, matching_data$response_time, lag.max = 30, plot = FALSE)
ccf_df <- data.frame(id = i, lag = ccf_result$lag, ccf_value = ccf_result$acf)
ccf_values <- bind_rows(ccf_values, ccf_df)
}, error = function(e) {
# If an error occurs, store the participant ID
error_ids_num <<- c(error_ids_num, i)
})
}
# Helper function to extract bootstrap CI
get_boot_ci <- function(boot_obj) {
# Check if boot_obj is valid and has non-missing values
if (all(is.na(boot_obj$t)) || length(unique(boot_obj$t)) <= 1) {
return(c(lower = NA, upper = NA))
}
ci <- boot.ci(boot_obj, type = "perc")
c(lower = ci$percent[4], upper = ci$percent[5])
}
# Bootstrapping and confidence intervals
bootstrap_results <- ccf_values %>%
group_by(lag) %>%
summarise(
boot_obj = list(boot(ccf_value, statistic = function(x, i) mean(x[i], na.rm = TRUE), R = 1000)),  # Run 1000 bootstrap samples
mean_ccf = mean(ccf_value, na.rm = TRUE)
) %>%
rowwise() %>%
mutate(
ci = list(get_boot_ci(boot_obj)),  # Apply helper function
lower_ci = ci[1],
upper_ci = ci[2]
) %>%
ungroup() %>%
select(lag, mean_ccf, lower_ci, upper_ci)
# Store results in a list
all_results_num[[num]] <- bootstrap_results
}
# Print results for each round number
for (num in names(all_results_num)) {
cat("\nResults for round number:", num, "\n")
print(all_results_num[[num]])
}
# Print IDs that caused errors
cat("\nParticipants that caused errors:\n")
print(error_ids_num)
View(ccf_df)
View(num_matching_df)
View(ccf_values)
View(ccf_result)
## Load packages
pacman::p_load('tidyverse', 'dslabs', 'cowplot')
## Load in the divorce margarine dataset
d <- read_csv('./data/WineDataset.csv')
## Cleaning up data
# Only bottles of 75 cl
d <- d %>%
mutate(Capacity = case_when(
str_detect(Capacity, "^750ML$|^75CL$") ~ "75",
TRUE ~ NA_character_
)) %>%
filter(!is.na(wine_size))
## Cleaning up data
# Only bottles of 75 cl
d <- d %>%
mutate(Capacity = case_when(
str_detect(Capacity, "^750ML$|^75CL$") ~ "75",
TRUE ~ NA_character_
)) %>%
filter(!is.na(Capacity))
# Fix prices
d <- d %>%
mutate(Price = as.numeric(str_extract(Price, "\\d+\\.?\\d*")))
View(d)
## Load packages
pacman::p_load('tidyverse', 'dslabs', 'cowplot', 'brms')
View(d)
View(d)
d <- d %>%
filter(!str_detect(Vintage, "NV"))
View(d)
# Define priors for the model
priors <- c(
set_prior("normal(0, 10)", class = "Intercept"),          # Prior for intercept
set_prior("normal(0, 5)", class = "b", coef = "Vintage"), # Prior for vintage effect
set_prior("normal(0, 5)", class = "b", coef = "Grape"), # Prior for grape variety
set_prior("normal(0, 5)", class = "b", coef = "Country")   # Prior for region
)
# Fit the Bayesian model
model <- brm(
Price ~ Grape + Vintage + Country,
data = d,
family = gaussian(),    # Assuming price follows a normal distribution
prior = priors,         # Apply specified priors
chains = 8,             # Number of MCMC chains
iter = 2000,            # Number of iterations per chain
seed = 123              # Seed for reproducibility
)
# Define priors for the model
priors <- c(
set_prior("normal(0, 10)", class = "Intercept"),          # Prior for intercept
set_prior("normal(0, 5)", class = "b", coef = "Vintage"), # Prior for vintage effect
set_prior("normal(0, 5)", class = "b", coef = "Grape"), # Prior for grape variety
set_prior("normal(0, 5)", class = "b", coef = "Country")   # Prior for region
)
# Fit the Bayesian model
model <- brm(
Price ~ b_Grape + b_Vintage + b_Country,
data = d,
family = gaussian(),    # Assuming price follows a normal distribution
prior = priors,         # Apply specified priors
chains = 8,             # Number of MCMC chains
iter = 2000,            # Number of iterations per chain
seed = 123              # Seed for reproducibility
)
## Load packages
pacman::p_load('tidyverse', 'dslabs', 'cowplot', 'brms')
## Load in the divorce margarine dataset
d <- read_csv('./data/WineDataset.csv')
View(d)
## Load packages
pacman::p_load('tidyverse', 'dslabs', 'cowplot', 'brms', 'dagitty')
## Check adjustment sets
adjustmentSets(dag, exposure = "Closure", outcome = "Price")
