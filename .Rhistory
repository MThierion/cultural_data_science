x = "Price",
y = "Frequency") +
theme_cowplot()
formula <- bf(price ~ closure + grape + country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 1), class = "b"),          # weakly informative priors
prior(normal(0, 1), class = "Intercept")
)
# Fit the Bayesian model
fit <- brm(
formula = formula,
data = sim_data,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit)
# Get the fixed effects
fixed_effects <- fixef(fit)
formula <- bf(price ~ closure + grape + country, family = Gamma())
prior(normal(0, 1), class = "b", lb = 0),     # Lower bound of 0
formula <- bf(price ~ closure + grape + country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 1), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 1), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit <- brm(
formula = formula,
data = sim_data,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit)
# Get the fixed effects
fixed_effects <- fixef(fit)
# Convert to a dataframe for plotting
coef_df <- data.frame(
Parameter = rownames(fixed_effects),
Estimate = fixed_effects[, "Estimate"],
CI_low = fixed_effects[, "Q2.5"],
CI_high = fixed_effects[, "Q97.5"]
)
## Inverse the dataframe to get interpretable values
## Therefore, add values from intercept to the estimates ### CHECK THIS INTERPRETABILITY OR NOT
coef_df <- coef_df %>%
mutate(Estimate = 1 / Estimate,
CI_low = 1 / CI_low,
CI_high = 1 / CI_high)
ggplot(coef_df, aes(x = Parameter, y = Estimate)) +
geom_point() +
geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.2) +
coord_flip() +
labs(
title = "Posterior Estimates with 95% CI - Simulated data",
x = "Parameter",
y = "Estimate"
) +
theme_cowplot()
## Posterior predictive check
pp_check(fit, n_draws = 50, type = "dens_overlay") +
ggtitle("Posterior Predictive Check - simulated data")
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 1), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 1), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = d_filt,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(lognormal(0, 1), class = "b"),          # Coefficients
prior(lognormal(0, 1), class = "Intercept")
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = d_filt,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 10), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 10), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = d_filt,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
```{r}
# Convert to a dataframe for plotting
coef_df_d <- data.frame(
Parameter = rownames(fixed_effects_d),
Estimate = fixed_effects_d[, "Estimate"],
CI_low = fixed_effects_d[, "Q2.5"],
CI_high = fixed_effects_d[, "Q97.5"]
)
plot(fit_d)  # Traceplots and density plots
## Load packages
pacman::p_load('tidyverse', 'dslabs', 'cowplot', 'brms', 'dagitty')
## Load in the divorce margarine dataset
d <- read_csv('./data/WineDataset.csv')
## Cleaning up data
# Only bottles of 75 cl
d <- d %>%
mutate(Capacity = case_when(
str_detect(Capacity, "^750ML$|^75CL$") ~ "75",
TRUE ~ NA_character_
)) %>%
filter(!is.na(Capacity))
# Fix prices
d <- d %>%
mutate(Price = as.numeric(str_extract(Price, "\\d+\\.?\\d*")))
# Setting lower bound
d_filt <- d %>%
group_by(Grape) %>%
filter(n() >= 5)
# Transforming grape names so synonyms are not in dataset
d_filt <- d_filt %>%
mutate(Grape = ifelse(Grape == "Shiraz", "Syrah", Grape),
Grape = ifelse(Grape == "Garnacha", "Grenache", Grape),
Grape = ifelse(Grape == "Pinot Grigio", "Pinot Gris", Grape),
Grape = ifelse(Grape == "Primitivo", "Zinfandel", Grape))
# Country count
d_count <- table(d_filt$Country)
d_count <- sort(d_count, decreasing = T)
print(d_count)
# Filtering
d_filt <- d_filt %>%
group_by(Country) %>%
filter(n() >= 8)
# Checking closure types
d_count <- table(d_filt$Closure)
d_count <- sort(d_count, decreasing = T)
print(d_count)
# Quick and dirty filtering of only screwcap and cork
d_filt <- d_filt %>%
group_by(Closure) %>%
filter(n() >= 18)
## Draw the DAG
dag <- dagitty("dag {
Country -> Grape
Country -> Closure
Country -> Price
Grape -> Price
Grape -> Closure
Closure -> Price
}")
plot(dag)
# Simulate country data
## Probabilities for 10 countries
n = 1000
categories <- c("France", "Italy", "Spain", "USA", "Australia")
probabilities <- c(0.3, 0.2, 0.2, 0.1, 0.2)
sim_data <- data.frame(
country = sample(categories, size = n, replace = TRUE, prob = probabilities)
)
## Simulate grape data
# Grape categories
grapes <- c("Chardonnay", "Sauvignon Blanc", "Cabernet Sauvignon", "Merlot",
"Pinot Noir")
# Define toy probabilities for grape varieties based on country
grape_probs <- list(
"France" = c(0.2, 0.2, 0.2, 0.2, 0.2),
"Italy" = c(0.05, 0.05, 0.2, 0.5, 0.2),
"Spain" = c(0.4, 0.2, 0.1, 0.2, 0.1),
"USA" = c(0.2, 0.3, 0.2, 0.1, 0.2),
"Australia" = c(0.2, 0.2, 0.4, 0, 0.2)
)
# Simulate grape data
sim_data$grape <- sapply(sim_data$country, function(c) {
sample(grapes, size = 1, replace = TRUE, prob = grape_probs[[c]])
})
# Define conditional probabilities for closure type based on country and grape
closure_probs <- list(
"France" = list(
"Chardonnay" = c(screwtop = 0.2, cork = 0.8),
"Sauvignon Blanc" = c(screwtop = 0.3, cork = 0.7),
"Cabernet Sauvignon" = c(screwtop = 0.2, cork = 0.8),
"Merlot" = c(screwtop = 0.3, cork = 0.7),
"Pinot Noir" = c(screwtop = 0.1, cork = 0.9)
),
"Australia" = list(
"Chardonnay" = c(screwtop = 0.8, cork = 0.2),
"Sauvignon Blanc" = c(screwtop = 0.9, cork = 0.1),
"Cabernet Sauvignon" = c(screwtop = 0.6, cork = 0.4),
"Merlot" = c(screwtop = 0.7, cork = 0.3),
"Pinot Noir" = c(screwtop = 0.7, cork = 0.3)
),
"Italy" = list(
"Chardonnay" = c(screwtop = 0.2, cork = 0.8),
"Sauvignon Blanc" = c(screwtop = 0.3, cork = 0.7),
"Cabernet Sauvignon" = c(screwtop = 0.1, cork = 0.9),
"Merlot" = c(screwtop = 0.2, cork = 0.8),
"Pinot Noir" = c(screwtop = 0.3, cork = 0.7)
),
"Spain" = list(
"Chardonnay" = c(screwtop = 0.4, cork = 0.6),
"Sauvignon Blanc" = c(screwtop = 0.4, cork = 0.6),
"Cabernet Sauvignon" = c(screwtop = 0.5, cork = 0.5),
"Merlot" = c(screwtop = 0.5, cork = 0.5),
"Pinot Noir" = c(screwtop = 0.4, cork = 0.6)
),
"USA" = list(
"Chardonnay" = c(screwtop = 0.7, cork = 0.3),
"Sauvignon Blanc" = c(screwtop = 0.8, cork = 0.2),
"Cabernet Sauvignon" = c(screwtop = 0.4, cork = 0.6),
"Merlot" = c(screwtop = 0.4, cork = 0.6),
"Pinot Noir" = c(screwtop = 0.5, cork = 0.5)
))
# Simulate closure type
sim_data$closure <- mapply(function(c, g) {
prob <- closure_probs[[c]][[g]]
sample(c("screwtop", "cork"), size = 1, replace = TRUE, prob = prob)
}, c = sim_data$country, g = sim_data$grape)
# Simulate price data
# Define base scale and shape parameters for gamma distribution
base_params <- list(
"France" = c(scale = 20, shape = 1.1),
"Italy" = c(scale = 15, shape = 1.4),
"Spain" = c(scale = 14, shape = 1.2),
"USA" = c(scale = 12, shape = 1.2),
"Australia" = c(scale = 10, shape = 1.5)
)
# Adjustments for grape varieties
grape_adjustments <- list(
"Chardonnay" = c(scale = 1, shape = 1),
"Sauvignon Blanc" = c(scale = 0.8, shape = 1.0),
"Cabernet Sauvignon" = c(scale = 1.2, shape = 1.2),
"Merlot" = c(scale = 1.1, shape = 1.1),
"Pinot Noir" = c(scale = 1.4, shape = 0.8)
# Extend for other grapes...
)
# Adjustments for closure type
closure_adjustments <- list(
"screwtop" = c(scale = 0.6, shape = 1),
"cork" = c(scale = 1.1, shape = 1)
)
# Calculate price using gamma distribution
sim_data$price <- mapply(function(c, g, cl) {
base <- base_params[[c]]
grape_adj <- grape_adjustments[[g]]
closure_adj <- closure_adjustments[[cl]]
scale <- base["scale"] * grape_adj["scale"] * closure_adj["scale"]
shape <- base["shape"] * grape_adj["shape"] * closure_adj["shape"]
rgamma(1, shape = shape, scale = scale)
}, c = sim_data$country, g = sim_data$grape, cl = sim_data$closure)
## Plotting the closure type x axis and price y as boxplots
sim_data %>%
ggplot(aes(closure, price)) +
geom_boxplot(fill = "skyblue", color = "black") +
labs(title = "Price distribution by closure type",
x = "Closure type",
y = "Price") +
theme_cowplot()
## Plot prices from sim_data
sim_data %>%
ggplot(aes(price)) +
geom_histogram(bins = 30, fill = "skyblue", color = "black") +
labs(title = "Simulated distribution of wine prices",
x = "Price",
y = "Frequency") +
theme_cowplot()
formula <- bf(price ~ closure + grape + country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 1), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 1), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit <- brm(
formula = formula,
data = sim_data,
prior = priors,
iter = 8000, warmup = 4000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit)
# Get the fixed effects
fixed_effects <- fixef(fit)
# Convert to a dataframe for plotting
coef_df <- data.frame(
Parameter = rownames(fixed_effects),
Estimate = fixed_effects[, "Estimate"],
CI_low = fixed_effects[, "Q2.5"],
CI_high = fixed_effects[, "Q97.5"]
)
## Inverse the dataframe to get interpretable values
## Therefore, add values from intercept to the estimates ### CHECK THIS INTERPRETABILITY OR NOT
coef_df <- coef_df %>%
mutate(Estimate = 1 / Estimate,
CI_low = 1 / CI_low,
CI_high = 1 / CI_high)
ggplot(coef_df, aes(x = Parameter, y = Estimate)) +
geom_point() +
geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.2) +
coord_flip() +
labs(
title = "Posterior Estimates with 95% CI - Simulated data",
x = "Parameter",
y = "Estimate"
) +
theme_cowplot()
## Posterior predictive check
pp_check(fit, n_draws = 50, type = "dens_overlay") +
ggtitle("Posterior Predictive Check - simulated data")
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 2), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 2), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = d_filt,
prior = priors,
iter = 16000, warmup = 8000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
data_filt <- d_filt %>% select(Price, Closure, Grape, Country)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 2), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 2), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = d_filt,
prior = priors,
iter = 16000, warmup = 8000, chains = 8, cores = 8,
control = list(adapt_delta = 0.99)
)
data_filt <- d_filt %>% select(Price, Closure, Grape, Country)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 2), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 2), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = data_filt,
prior = priors,
iter = 16000, warmup = 8000, chains = 8, cores = 8,
control = list(adapt_delta = 0.99)
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
load("C:/Users/grazz/Desktop/poi_sog/scripts/data_trend_std.RData")
View(data_trend_std)
pacman::p_load('tidyverse', 'cowplot', 'clipr', 'lme4', 'rstan', 'brms', 'rethinking', 'truncnorm')
source("R_rainclouds.R")
write_csv(data_trend_std, "data_trend_std.csv")
pacman::p_load('tidyverse', 'cowplot', 'clipr', 'lme4', 'rstan', 'brms', 'rethinking', 'truncnorm')
source("R_rainclouds.R")
write_csv(data_trend_std, "data_trend_std.csv")
data_trend_std <- data_trend_std %>%
select(-c77)
data_trend_std <- data_trend_std %>%
select(-77)
write_csv(data_trend_std, "data_trend_std.csv")
data_filt <- d_filt %>% select(Price, Closure, Grape, Country)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 4), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 4), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = data_filt,
prior = priors,
iter = 16000, warmup = 8000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
# Setting lower bound
d_filt <- d %>%
group_by(Grape) %>%
filter(n() >= 69)
# Transforming grape names so synonyms are not in dataset
d_filt <- d_filt %>%
mutate(Grape = ifelse(Grape == "Shiraz", "Syrah", Grape),
Grape = ifelse(Grape == "Garnacha", "Grenache", Grape),
Grape = ifelse(Grape == "Pinot Grigio", "Pinot Gris", Grape),
Grape = ifelse(Grape == "Primitivo", "Zinfandel", Grape))
# Country count
d_count <- table(d_filt$Country)
d_count <- sort(d_count, decreasing = T)
print(d_count)
# Country count
d_count <- table(d_filt$Country)
d_count <- sort(d_count, decreasing = T)
print(d_count)
# Filtering
d_filt <- d_filt %>%
group_by(Country) %>%
filter(n() >= 26)
# Checking closure types
d_count <- table(d_filt$Closure)
d_count <- sort(d_count, decreasing = T)
print(d_count)
# Quick and dirty filtering of only screwcap and cork
d_filt <- d_filt %>%
group_by(Closure) %>%
filter(n() >= 18)
## Viz the distribution of wine prices
d_filt %>%
ggplot(aes(Price)) +
geom_histogram(bins = 30, fill = "skyblue", color = "black") +
labs(title = "Distribution of wine prices",
x = "Price",
y = "Frequency") +
theme_cowplot()
## Plotting boxplots of closure type and price
d_filt %>%
ggplot(aes(Closure, Price)) +
geom_boxplot(fill = "skyblue", color = "black") +
labs(title = "Price distribution by closure type",
x = "Closure type",
y = "Price") +
theme_cowplot()
data_filt <- d_filt %>% select(Price, Closure, Grape, Country)
## Running with real data
formula <- bf(Price ~ Closure + Grape + Country, family = Gamma())
# Define priors for the model
priors <- c(
prior(normal(0, 2), class = "b", lb = 0),     # Lower bound of 0
prior(normal(0, 2), class = "Intercept", lb = 0)
)
# Fit the Bayesian model
fit_d <- brm(
formula = formula,
data = data_filt,
prior = priors,
iter = 16000, warmup = 8000, chains = 8, cores = 8
)
# Print a summary of the model
summary(fit_d)
# Get the fixed effects
fixed_effects_d <- fixef(fit_d)
# Convert to a dataframe for plotting
coef_df_d <- data.frame(
Parameter = rownames(fixed_effects_d),
Estimate = fixed_effects_d[, "Estimate"],
CI_low = fixed_effects_d[, "Q2.5"],
CI_high = fixed_effects_d[, "Q97.5"]
)
## Inverse the dataframe to get interpretable values
coef_df_d <- coef_df_d %>%
mutate(Estimate = 1 / Estimate,
CI_low = 1 / CI_low,
CI_high = 1 / CI_high)
ggplot(coef_df_d, aes(x = Parameter, y = Estimate)) +
geom_point() +
geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.2) +
coord_flip() +
labs(
title = "Posterior Estimates with 95% CI - Collected data",
x = "Parameter",
y = "Estimate"
) +
theme_cowplot()
## Posterior predictive check
pp_check(fit_d, n_draws = 50, type = "dens_overlay") +
ggtitle("Posterior Predictive Check - Collected data")
